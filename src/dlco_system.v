
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module dlco_system(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD
);



//=======================================================
//  REG/WIRE declarations
//=======================================================

wire [31:0] iaddr, idataout, daddr, ddataout, ddata, ddatain, PC;
wire [31:0] keymemout;
wire [2:0] dop;
wire iclk, drdclk, dwrclk;
wire cpu_we, data_we, vga_we, vga_rollen, key_rd, gmem_we, ledr_we, hex_we;
wire ascii_or_pixel_we;

reg [31:0] cpu_data;

// instr: 000, data: 001, vga: 002, ps2: 003, ...
assign data_we	=(daddr[31:20] == 12'h001)? cpu_we : 1'b0;
assign vga_we	=(daddr[31:20] == 12'h002)? cpu_we : 1'b0;
assign gmem_we	=(daddr[31:20] == 12'h006)? cpu_we : 1'b0;
assign vga_rollen	=(daddr == 32'h00500000)? cpu_we : 1'b0; // 起始行号寄存器
assign ascii_or_pixel_we = (daddr == 32'h00500010) ? cpu_we : 1'b0; // CPU要修改ascii_or_pixel控制寄存器
assign ledr_we	=(daddr[31:20] == 12'h009)? cpu_we : 1'b0;
assign hex_we	=(daddr[31:20] == 12'h00A)? cpu_we : 1'b0;
// not for CPU
assign key_rd	=(daddr[31:20] == 12'h003);

always @(*) begin
	if (daddr[31:20] == 12'h001) begin // 选取dmem输出
		cpu_data = ddataout; 
	end else if (daddr[31:20] == 12'h003) begin // 键盘输出
		cpu_data = keymemout;
	end else if (daddr[31:20] == 12'h004) begin // 时钟输出
		cpu_data = us_cnt;
	end else if (daddr == 32'h00500000) begin // 起始行号寄存器(read only)
		cpu_data = {27'b0, start_line};
	end else if (daddr == 32'h00500004) begin // 字符颜色寄存器
		cpu_data = us_cnt;
	end else if (daddr[31:20] == 12'h007) begin // 开发板开关
		cpu_data = {31'b0, SW[daddr[3:0]]};
	end else if (daddr[31:20] == 12'h008) begin // 开发板按键
		cpu_data = {31'b0, KEY[daddr[1:0]]};
	end else begin
		cpu_data = 32'b0;
	end
end

// VGA + vmem
wire [11:0] vga_data;
wire [9:0] h_addr, v_addr;
wire [3:0] vga_r, vga_g, vga_b;

wire [7:0] vdataout;
wire [11:0] gdataout;
wire [11:0] vrdaddr;
wire [6:0] vrdaddr_h;
wire [4:0] vrdaddr_v;
wire [14:0] gdaddr;
reg ascii_or_pixel;

// KBD
reg nextdata_n;
wire [7:0] keydata, kfifodata;
wire rdempty, wrfull, ready, overflow;

// CLK
wire clk, cpuclk, vgaclk, kbdclk, vrdclk;

// reset
wire rst;
assign rst = SW[0];

//=======================================================
//  Structural coding
//=======================================================


// CPU
// 下降沿写, 上升沿读
				
rv32is_pipe2 my_rv32is( // in out 是相对于rv32is来说的
	.clock(cpuclk),
	.reset(rst),
	.imemaddr(iaddr),
	.imemdataout(idataout),
	.imemclk(iclk),
	.dmemaddr(daddr), 
	.dmemdataout(cpu_data), // 给 CPU 的数据
	.dmemdatain(ddatain), // CPU 给的
	.dmemrdclk(drdclk),
	.dmemwrclk(dwrclk),
	.dmemop(dop),
	.dmemwe(cpu_we),
	.dbgdata(PC)
);

// dmem: [0x00100000, 0x0011ffff)
// 和exp11类似,, 只不过这里的data_we要转换成特定模块的we
// dmem 分配了 2^17 Byte的空间, 提供的地址应当是17bit的, 输出则是32bit的, 怎么取值和memop相关
dmem_ctrl my_dmem_ctrl(
	.addr(daddr[16:0]),
	.dataout(ddataout),
	.datain(ddatain),
	.rdclk(drdclk),
	.wrclk(dwrclk),
	.memop(dop),
	.we(data_we)
);


// imem: [0x00000000, 0x0001ffff)
// imem 分配了 2^15 * 4Byte的空间, 因为rv32的缘故, 指令是定长的, 只需要提供15bit的地址信息, 

imem my_imem(
	.address(iaddr[16:2]),
	.clock(iclk),
	.q(idataout)
);

// vga: [0x00200000, 0x00201000)
// 显存大小为 64*64 Byte. 
// TBD: 此外可以将0x00201000映射到起始行号寄存器, 0x00201001颜色寄存器...
// 上升沿cpu写, 下降沿vga读

assign vrdaddr = {vrdaddr_v + start_line, vrdaddr_h};

vmem my_vmem(
	.data(ddatain[7:0]),
	.rdaddress(vrdaddr), // VGA 读
	.rdclock(vrdclk),
	.wraddress(daddr[11:0]), // cpu 写
	.wrclock(dwrclk),
	.wren(vga_we),
	.q(vdataout)
);

gmem my_gmem(
	.data(ddatain[11:0]), // 只有4位*3=12位色，因此只取低地址的12位
	.rdaddress(gdaddr),  // graphics读地址
	.rdclock(vrdclk),
	// 640*512的分辨率，低9位为512，高10位为640
	// 但是板上资源不够，像素4*4合一，分辨率是160*128，低7位为128，共15位
	.wraddress(daddr[14:0]), 
	.wrclock(dwrclk),
	.wren(gmem_we),
	.q(gdataout)
);

assign VGA_R = {vga_r, 4'b0};
assign VGA_G = {vga_g, 4'b0};
assign VGA_B = {vga_b, 4'b0};
assign VGA_SYNC_N = 0;
assign VGA_CLK = vgaclk;

// 非常恐怖啊, 时序问题,,,
// vgaclk=clk, 在整个时钟周期下降沿displayer会从vmem读入vdataout, 在上升沿输出到vga_data.

// upd: 因为想同时支持字符界面和图形界面, 因此需要MUX出vdataout和gdataout, 这部分在displayer里面魔改
displayer my_displayer(
	.clk(vgaclk),
	.ascii(vdataout), // read from vmem
	.pixel(gdataout), // read from gmem
	.ascii_or_pixel(ascii_or_pixel), // MUX (0->ascii, 1->pixel)
	.h_addr(h_addr),
	.v_addr(v_addr),
	.data(vga_data),
	.vrdclk(vrdclk), // let VGA tell vmem when to read
	.vrdaddr_h(vrdaddr_h),
	.vrdaddr_v(vrdaddr_v),
	.gdaddr(gdaddr)
);

vga_ctrl vga_inst(
	.pclk(vgaclk),
	.reset(rst),
	.vga_data(vga_data),
	.h_addr(h_addr),
	.v_addr(v_addr),
	.hsync(VGA_HS),
	.vsync(VGA_VS),
	.valid(VGA_BLANK_N),
	.vga_r(vga_r),
	.vga_g(vga_g),
	.vga_b(vga_b)
);

//wire [7:0] tmp1, tmp2;

// ps2

initial begin
	nextdata_n <= 1'b1;
end

always @(negedge drdclk) begin
	if (nextdata_n == 1'b0) nextdata_n <= 1'b1;
	else if (ready) nextdata_n <= 1'b0;
	else nextdata_n <= 1'b1;
end

wire shift, caps, ctrl, alt, is_dir; // kbd ctrl signals
wire clk_as; // ascii_cnt's clk
wire kbden; // fifo wrreq

keyboard kbd_inst(
	.clk(kbdclk),
	.clrn(~rst),
	.ps2_clk(PS2_CLK),
	.ps2_data(PS2_DAT),
	.ascii_key(keydata),
	.shift(shift),
	.caps(caps),
	.ctrl(ctrl),
	.alt(alt),
	.is_dir(is_dir)
);

clk_slow as_clk(
	.clk(CLOCK_50),
	.out(clk_as)
);

ascii_cnt my_cnt(
	.clk(clk_as),
	.en(kbden),
	.ascii(keydata)
);

handmade_fifo my_fifo(
	.data(keydata),
	.rdclk(drdclk),
	.rdreq(key_rd),
	.wrclk(kbden),
	.wrreq(1'b1),
	.q(kfifodata),
	.rdempty(rdempty),
	.wrfull(wrfull)
);

// for kfifo test
//reg [4:0] kbden_cnt;
//initial kbden_cnt = 5'b0;
//always @ (posedge kbden) begin
//	kbden_cnt <= kbden_cnt + 1;
//end
// assign LEDR[4:0] = kbden_cnt;
// assign LEDR[5] = kbden;
//bcd7seg seg0(keydata[3:0], HEX0);
//bcd7seg seg1(keydata[7:4], HEX1);
// end of fifo test

assign keymemout = rdempty ? 8'b0 : kfifodata;

// CLK
clkgen #(25000000) my_clk(
	.clkin(CLOCK_50),
	.clken(1'b1),
	.clkout(clk)
);

reg [31:0] us_cnt, clock_cnt;
initial begin 
	us_cnt <= 32'b0;
	clock_cnt <= 32'b0;
end
always @(posedge CLOCK_50) begin
	if (clock_cnt == 49) begin
		us_cnt <= us_cnt + 1;
		clock_cnt <= 32'b0;
	end
	else clock_cnt <= clock_cnt + 1;
end

// CTRL 
reg [4:0] start_line;
initial begin
	start_line <= 5'b0;
end

always @(posedge dwrclk) begin
	if (vga_rollen) begin
		start_line <= ddatain[4:0];
	end
	if (ascii_or_pixel_we) begin
		ascii_or_pixel <= ddatain[0];
	end
end

// HEX and LEDR
reg [9:0] ledr_r;
reg [3:0] hex_r[5:0];
always @ (posedge ledr_we) begin
	ledr_r[9:0] <= ddatain[9:0];
end

always @ (posedge dwrclk) begin
	if (hex_we) hex_r[daddr[2:0]] <= ddatain[3:0];
end

assign LEDR[9:0] = ledr_r[9:0];

bcd7seg seg0(hex_r[0], HEX0);
bcd7seg seg1(hex_r[1], HEX1);
bcd7seg seg2(hex_r[2], HEX2);
bcd7seg seg3(hex_r[3], HEX3);
bcd7seg seg4(hex_r[4], HEX4);
bcd7seg seg5(hex_r[5], HEX5);

assign cpuclk = clk;
assign vgaclk = clk;
assign kbdclk = clk;

endmodule
